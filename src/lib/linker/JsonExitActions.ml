(* 
  Generates P4 externs from json config file. 
  - entry event trigger table
  - exit event action table
*)

module CL = Caml.List
module BS = Batteries.String
open MiscUtils
open Printf
open Format
open Core
module DBG = BackendLogging
open Yojson.Basic.Util
open P4ExternSyntax

let outc = ref None
let dprint_endline = ref DBG.no_printf
let start_log () = DBG.start_mlog __FILE__ outc dprint_endline

exception Error of string

let error s = raise (Error s)

(* pragma in the harness that gets replaced 
   with the code generated by this module. *)
let obj_pragma = "EXIT_OBJECTS"
let call_pragma = "EXIT_CALL"
let json_block_name = "exit"
let tname = "exit_table"

(* internal representation of an exit action spec *)
type exit_spec =
  { name : string
  ; outputs : (string * string) list
  }

let extract_spec json_spec =
  { name = member "event" json_spec |> to_string
  ; outputs =
      member "outputs" json_spec
      |> to_assoc
      |> CL.map (fun (k, v) -> k, to_string v)
  }
;;

let extract_specs configfn =
  In_channel.read_all configfn
  |> Yojson.Basic.from_string (* parse from string *)
  |> member json_block_name (* find triggers block *)
  |> convert_each extract_spec
;;

(* convert each item into an ev spec *)

let exit_event_field =
  sprintf
    "%s.%s.%s"
    LLConstants.md_instance_prefix
    LLConstants.dpt_meta_str
    LLConstants.exit_event_str
;;

let event_const_id = LLOp.TofinoStructs.defname_from_evname

(* convert an exit spec from json into a 
   table rule (that includes an action) *)
let exit_spec_to_rule espec =
  let rule =
    { guard =
        [{ field = exit_event_field; value = VName (event_const_id espec.name) }]
    ; action =
        { aname = "a_" ^ espec.name
        ; aparams = []
        ; acmds =
            CL.map
              (fun (p4var, lucidvar) ->
                cassign p4var (param_to_p4field espec.name lucidvar))
              espec.outputs
        }
    ; action_args = []
    }
  in
  rule
;;

let exit_specs_to_rules especs = CL.map exit_spec_to_rule especs

(* generate the exit actions, table, and call string. *)
let generate configfn =
  let _ = configfn in
  let specs = extract_specs configfn in
  let rules = exit_specs_to_rules specs in
  let table = assemble_table tname rules in
  (* there must be an exit event for this table to fire. *)
  let objs_str =
    String.concat
      ~sep:"\n"
      [actions_from_table table |> actions_to_string; table_to_string table]
  in
  let call = sif (neqtest_to_bexpr exit_event_field "0") (scall table) in
  let call_str = stmt_to_string call in
  [obj_pragma, objs_str; call_pragma, call_str]
;;
