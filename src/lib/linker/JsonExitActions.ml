(* 
  Generates P4 externs from json config file. 
  - entry event trigger table
  - exit event action table
*)

module CL = Caml.List
module BS = Batteries.String
open MiscUtils
open Printf
open Format
open Core
module DBG = BackendLogging
open Yojson.Basic.Util
open P4ExternSyntax

let outc = ref None
let dprint_endline = ref DBG.no_printf
let start_log () = DBG.start_mlog __FILE__ outc dprint_endline
exception Error of string
let error s = raise (Error s)

(* pragma in the harness that gets replaced 
   with the code generated by this module. *)
let obj_pragma = "EXIT_ACTION_OBJECTS"
let call_pragma = "EXIT_ACTION_CALL"
let json_block_name = "exit" 
let tname = "exit_handlers"

(* internal representation of an exit action spec *)
type exit_spec = {
  name : string;
  outputs : (string * string) list;
}
let extract_spec json_spec = 
  {
    name = member "event" json_spec |> to_string;
    outputs = member "outputs" json_spec 
      |> to_assoc 
      |> CL.map (fun (k, v) -> k, to_string v);
  }
;;
let extract_specs configfn = 
  In_channel.read_all configfn 
    |> Yojson.Basic.from_string (* parse from string *)
    |> member json_block_name (* find triggers block *)
    |> convert_each extract_spec (* convert each item into an ev spec *)
;;

let exit_event_field = sprintf "%s.%s.%s" LLConstants.md_instance_prefix LLConstants.dpt_meta_str LLConstants.exit_event_str
;;
let event_const_id = LLOp.TofinoStructs.defname_from_evname
;;

(* convert an exit spec from json into a 
   table rule (that includes an action) *)
let exit_spec_to_rule espec = 
  let rule = {
    guard = [{
      field = exit_event_field;
      value = VName (event_const_id espec.name);    
    }];
    action = {
      aname = "a_"^(espec.name);
      aparams = [];
      acmds = CL.map (fun (p4var, lucidvar) -> cassign p4var (param_to_p4field espec.name lucidvar)) espec.outputs;    
    };
    action_args = [];
  }
  in 
  rule 
;;
let exit_specs_to_rules especs = 
  CL.map exit_spec_to_rule especs
;;

(* generate the exit actions, table, and call string. *)
let generate configfn =
  let _ = configfn in  
  let specs = extract_specs configfn in 
  let rules = exit_specs_to_rules specs in 
  let table = assemble_table tname rules in 
  (* there must be an exit event for this table to fire. *)
  let objs_str = String.concat 
    ~sep:"\n"
    [
      actions_from_table table |> actions_to_string;
      table_to_string table
    ]
  in 
  let call = sif (neqtest_to_bexpr exit_event_field "0") (scall table) in 
  let call_str = stmt_to_string call in 
  [obj_pragma, objs_str; call_pragma, call_str]
;;
