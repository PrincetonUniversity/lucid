const int OUT_PORT = 1;
const int SERVER_PORT = 2;
const int SEED = 7;

// ethernet and ip packet headers
type eth_t = {
	int<48> dmac;
	int<48> smac;
	int<16> etype;
}
type ip_t = {
	int src;
	int dst;
	int<16> len;
}
type eth_ip_t = {
    eth_t eth;
    ip_t ip;
}

/********** Events *********/
packet event eth_ip(eth_t eth, ip_t ip);

/********** Tables *********/
action int result(int prefix_len)() {
	return prefix_len;
}

table_type prefix_table_t = {
    key_size: (32, 32, 32, 32)
    arg_types: ()
    ret_type: int
}

/********** Modules *********/
// module implementing a table to match prefixes of IPv4 addresses
module PrefixTable {
    type t = {
        prefix_table_t prefix_table;
    }

    constr t create() = {
        prefix_table = table_create<prefix_table_t>(
            (result),
            1024,
            result(0)
        );
    };

    fun int prefix_match(t table, int ip_addr) {
        int<8>[4] ip_octets = [ip_addr[31:24]; ip_addr[23:16]; ip_addr[15:8]; ip_addr[7:0]];
        int prefix_length = table_match(
            table#prefix_table, 
            ((int<32>)ip_octets[0], (int<32>)ip_octets[1], (int<32>)ip_octets[2], (int<32>)ip_octets[3]), 
            ());
        return prefix_length;
    }
}

global PrefixTable.t src_prefix_table = PrefixTable.create();
global PrefixTable.t dst_prefix_table = PrefixTable.create();

// module implementing policy to use when anonymizing ethernet and ip packets
module AnonPolicy {
    type t = {
        bool[6] policy;
    }

    constr t create(bool[6] policy) = {
        policy = policy;
    };

    fun bool get_multicast_broadcast(t anon_policy) {
        return anon_policy#policy[0];
    }

    fun bool get_srcmac_oui(t anon_policy) {
        return anon_policy#policy[1];
    }

    fun bool get_srcmac_id(t anon_policy) {
        return anon_policy#policy[2];
    }

    fun bool get_dstmac_oui(t anon_policy) {
        return anon_policy#policy[3];
    }

    fun bool get_dstmac_id(t anon_policy) {
        return anon_policy#policy[4];
    }

    fun bool get_preserve_prefix(t anon_policy) {
        return anon_policy#policy[5];
    }
}

global AnonPolicy.t anon_policy = AnonPolicy.create([false; true; true; true; true; true]);

/********** Functions *********/
fun bool should_anonymize(eth_t eth, ip_t ip, bool multicast_broadcast) {
    if (!multicast_broadcast && eth#dmac[40:40] == 1) { // if policy says don't anonymize multicast/broadcast
        return false;
    } else {
        return true;
    }
}

fun int<24> anonymize_24_bits(int<24> num, bool anonymize) {
    if (anonymize) {
        return hash<24>(SEED, num);
    } else {
        return num;
    }
}

fun int<48> anonymize_mac(int<48> address, bool anonymize_oui, bool anonymize_id) {
    int<24> oui = address[47:24];
    int<24> id = address[23:0];
    return anonymize_24_bits(oui, anonymize_oui) ^ anonymize_24_bits(id, anonymize_id);
}

fun int anonymize_ip_prefix_16(int ip, bool preserve_prefix) {
    int<16> prefix = ip[31:16];
    if (!preserve_prefix) {
        prefix = hash<16>(SEED, prefix);
    }
    int<16> rest = hash<16>(SEED, ip[15:0]);
    return prefix ^ rest;
}

fun int anonymize_ip_prefix_24(int ip, bool preserve_prefix) {
    int<24> prefix = ip[31:8];
    if (!preserve_prefix) {
        prefix = hash<24>(SEED, prefix);
    }
    int<8> rest = hash<8>(SEED, ip[7:0]);
    return prefix ^ rest;
}

fun int anonymize_ip(int ip_addr, PrefixTable.t table, bool preserve_prefix) {
    int prefix_len = PrefixTable.prefix_match(table, ip_addr);
    match (prefix_len) with
    | 16 -> {return anonymize_ip_prefix_16(ip_addr, preserve_prefix);}
    | 24 -> {return anonymize_ip_prefix_24(ip_addr, preserve_prefix);}
    | _ -> {return ip_addr;}
}

fun eth_ip_t anonymize_packet(eth_t eth, ip_t ip) {
    if (!should_anonymize(eth, ip, AnonPolicy.get_multicast_broadcast(anon_policy))) {
        return {eth = eth; ip = ip;};
    } else {
        // anonymize MAC addresses
        int<48> smac = anonymize_mac(
            eth#smac, AnonPolicy.get_srcmac_oui(anon_policy), AnonPolicy.get_srcmac_id(anon_policy));
        int<48> dmac = anonymize_mac(
            eth#dmac, AnonPolicy.get_dstmac_oui(anon_policy), AnonPolicy.get_dstmac_id(anon_policy));
        eth_t anonymized_eth = {eth with dmac = dmac; smac = smac};

        // anonymize IPv4 addresses
        bool preserve_prefix = AnonPolicy.get_preserve_prefix(anon_policy);
        int src_ip = anonymize_ip(ip#src, src_prefix_table, preserve_prefix);
        int dst_ip = anonymize_ip(ip#dst, dst_prefix_table, preserve_prefix);
        ip_t anonymized_ip = {ip with src = src_ip; dst = dst_ip};

        return {eth = anonymized_eth; ip = anonymized_ip;};
    }
}

/********** Handlers *********/
handle eth_ip(eth_t eth, ip_t ip) {
	// 1. forward an event representing the packet out of port 1.
	generate_port(OUT_PORT, eth_ip(eth, ip));
	// 2. anonymize packet info before sending to the monitoring server.
    eth_ip_t anonymized_packet = anonymize_packet(eth, ip);
    generate_port(SERVER_PORT, eth_ip(anonymized_packet#eth, anonymized_packet#ip));
}


/*******************/


/********** Extra Unused Functions *********/
fun int<auto> get_n_bits(int<auto> num, int<auto> first_bit, int<auto> num_bits) {
    int<auto> shifted_to_first_bit = num >> first_bit;
    int<auto> wanted_bits_removed = shifted_to_first_bit >> num_bits;
    if (wanted_bits_removed != 0) {
        wanted_bits_removed = wanted_bits_removed << num_bits;
    }
    int<auto> wanted_bits = (int<auto>)(shifted_to_first_bit - wanted_bits_removed);
    return wanted_bits;
}

fun int<auto> zero_n_bits(int<auto> num, int<auto> first_bit, int<auto> num_bits) {
    int<auto> bits_to_zero = (get_n_bits(num, first_bit, num_bits)) << first_bit;
    return num - bits_to_zero;
}

fun int<8>[4] extract_ip_v4_octets(int ip_addr) {
    return [ip_addr[31:24]; ip_addr[23:16]; ip_addr[15:8]; ip_addr[7:0]];
}