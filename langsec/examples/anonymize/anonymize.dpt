const int OUT_PORT = 1;
const int SERVER_PORT = 2;
const int SEED = 7;
const int<48> FULL_MASK = 0xffffffffffff;

// ethernet and ip packet headers
type eth_t = {
	int<48> dmac;
	int<48> smac;
	int<16> etype;
}
type ip_t = {
	int src;
	int dst;
	int<16> len;
}
type eth_ip_t = {
    eth_t eth;
    ip_t ip;
}
type split_int_t<'sz> = {
    int prefix;
    int<'sz> suffix;
}
type policy_t = {
    bool multicast_broadcast;
    bool srcmac_oui;
    bool srcmac_id;
    bool dstmac_oui;
    bool dstmac_id;
    bool preserve_prefix;
}

/********** Events *********/
packet event eth_ip(eth_t eth, ip_t ip);

/********** Tables *********/
action int result(int prefix_len)() {
	return prefix_len;
}

table_type prefix_table_t = {
    key_size: (32, 32, 32, 32)
    arg_types: ()
    ret_type: int
}

action policy_t get_policy(
                bool multicast_broadcast, 
                bool srcmac_oui, bool srcmac_id, 
                bool dstmac_oui, bool dstmac_id, 
                bool preserve_prefix)() {
    return {
        multicast_broadcast = multicast_broadcast;
        srcmac_oui = srcmac_oui; srcmac_id = srcmac_id;
        dstmac_oui = dstmac_oui; dstmac_id = dstmac_id;
        preserve_prefix = preserve_prefix;
    };
}

table_type policy_table_t = {
    key_size: (32)
    arg_types: ()
    ret_type: policy_t
}

/********** Modules *********/
// module implementing a table to match prefixes of IPv4 addresses
module PrefixTable {
    type t = {
        prefix_table_t prefix_table;
    }

    constr t create() = {
        prefix_table = table_create<prefix_table_t>(
            (result),
            1024,
            result(0)
        );
    };

    fun int prefix_match(t table, int ip_addr) {
        int<8>[4] ip_octets = [ip_addr[31:24]; ip_addr[23:16]; ip_addr[15:8]; ip_addr[7:0]];
        int prefix_length = table_match(
            table#prefix_table, 
            ((int<32>)ip_octets[0], (int<32>)ip_octets[1], (int<32>)ip_octets[2], (int<32>)ip_octets[3]), 
            ());
        return prefix_length;
    }
}

// module implementing an anonymizer that anonymizes packet info based on the provided policy
module Anonymizer {
    type t = {
        policy_table_t policy_table;
        PrefixTable.t src_prefix_table;
        PrefixTable.t dst_prefix_table;
    }

    constr t create() = {
        policy_table = table_create<policy_table_t>(
            (get_policy),
            1,
            get_policy(false, false, false, false, false, false)
        );
        src_prefix_table = PrefixTable.create();
        dst_prefix_table = PrefixTable.create();
    };

    fun bool should_anonymize(eth_t eth, bool multicast_broadcast) {
        if (!multicast_broadcast && eth#dmac[40:40] == 1) {
            return false;
        } else {
            return true;
        }
    }

    fun split_int_t<'sz> anonymize_num(int<'a> num, bool anonymize_prefix, bool anonymize_suffix) {
        int<'a> prefix_mask = (int<'a>)(FULL_MASK << size_to_int('sz));
        int<'a> prefix = num & prefix_mask;
        int<'sz> suffix = (int<'sz>)(num - prefix);

        if (anonymize_prefix) {
            prefix = hash<'a>(SEED, prefix);
        }
        prefix = prefix >> size_to_int('sz);
        if (anonymize_suffix) {
            suffix = hash<'sz>(SEED, suffix);
        }

        return {prefix = (int<32>)prefix; suffix = suffix;};
    }

    fun int<48> anonymize_mac(int<48> address, bool anonymize_oui, bool anonymize_id) {
        split_int_t<24> split_mac = anonymize_num(address, anonymize_oui, anonymize_id);
        return (int<24>)(split_mac#prefix) ^ split_mac#suffix;
    }

    fun int anonymize_ip(int ip_addr, PrefixTable.t table, bool preserve_prefix) {
        int prefix_len = PrefixTable.prefix_match(table, ip_addr);
        match (prefix_len) with
        | 16 -> {
            split_int_t<16> split_ip = anonymize_num(ip_addr, !preserve_prefix, true);
            return (int<16>)(split_ip#prefix) ^ split_ip#suffix;}
        | 24 -> {
            split_int_t<8> split_ip = anonymize_num(ip_addr, !preserve_prefix, true);
            return (int<24>)(split_ip#prefix) ^ split_ip#suffix;}
        | _ -> {return ip_addr;}
    }

    fun eth_ip_t anonymize_packet(t anonymizer, eth_t eth, ip_t ip) {
        policy_t policy = table_match(anonymizer#policy_table, (1), ());
        if (!should_anonymize(eth, policy#multicast_broadcast)) {
            return {eth = eth; ip = ip;};
        } else {
            // anonymize MAC addresses
            int<48> smac = anonymize_mac(
                eth#smac, policy#srcmac_oui, policy#srcmac_id);
            int<48> dmac = anonymize_mac(
                eth#dmac, policy#dstmac_oui, policy#dstmac_id);
            eth_t anonymized_eth = {eth with dmac = dmac; smac = smac};

            // anonymize IPv4 addresses
            int src_ip = anonymize_ip(
                ip#src, anonymizer#src_prefix_table, policy#preserve_prefix);
            int dst_ip = anonymize_ip(
                ip#dst, anonymizer#dst_prefix_table, policy#preserve_prefix);
            ip_t anonymized_ip = {ip with src = src_ip; dst = dst_ip};

            return {eth = anonymized_eth; ip = anonymized_ip;};
        }
    }
}

global Anonymizer.t anonymizer = Anonymizer.create();

/********** Handlers *********/
handle eth_ip(eth_t eth, ip_t ip) {
	// 1. forward an event representing the packet out of port 1.
	generate_port(OUT_PORT, eth_ip(eth, ip));
	// 2. anonymize packet info before sending to the monitoring server.
    eth_ip_t anonymized_packet = Anonymizer.anonymize_packet(anonymizer, eth, ip);
    generate_port(SERVER_PORT, eth_ip(anonymized_packet#eth, anonymized_packet#ip));
}