/********** Modules *********/
// module implementing a table to match prefixes of IPv4 addresses
module PrefixTable {
    action int result(int prefix_len)() {
        return prefix_len;
    }

    table_type prefix_table_t = {
        key_size: (32, 32, 32, 32)
        arg_types: ()
        ret_type: int
    }

    type t = {
        prefix_table_t prefix_table;
    }

    constr t create() = {
        prefix_table = table_create<prefix_table_t>(
            (result),
            1024,
            result(0)
        );
    };

    fun int prefix_match(t table, HIGH int ip_addr) {
        // int<8>[4] ip_octets = [ip_addr[31:24]; ip_addr[23:16]; ip_addr[15:8]; ip_addr[7:0]];
        int prefix_length = table_match(
            table#prefix_table, 
            ((int<32>)ip_addr[31:24], (int<32>)ip_addr[23:16], (int<32>)ip_addr[15:8], (int<32>)ip_addr[7:0]), 
            ());
        return prefix_length;
    }
}

// module implementing an anonymizer that anonymizes packet info based on the provided policy
module Anonymizer {
    type eth_t = {
        int<48> dmac;
        int<48> smac;
        int<16> etype;
    }

    type ip_t = {
        int src;
        int dst;
        int<16> len;
    }

    type eth_ip_t = {
        eth_t eth;
        ip_t ip;
    }

    type split_int_t<'sz> = {
        int prefix;
        int<'sz> suffix;
    }

    type policy_t = {
        bool multicast_broadcast;
        bool srcmac_oui;
        bool srcmac_id;
        bool dstmac_oui;
        bool dstmac_id;
        bool preserve_prefix;
    }

    action policy_t get_policy(
                    bool multicast_broadcast, 
                    bool srcmac_oui, bool srcmac_id, 
                    bool dstmac_oui, bool dstmac_id, 
                    bool preserve_prefix)() {
        return {
            multicast_broadcast = multicast_broadcast;
            srcmac_oui = srcmac_oui; srcmac_id = srcmac_id;
            dstmac_oui = dstmac_oui; dstmac_id = dstmac_id;
            preserve_prefix = preserve_prefix;
        };
    }

    table_type policy_table_t = {
        key_size: (32)
        arg_types: ()
        ret_type: policy_t
    }

    type t = {
        policy_table_t policy_table;
        PrefixTable.t src_prefix_table;
        PrefixTable.t dst_prefix_table;
    }

    const int SEED = 7;
    const int<48> FULL_MASK = 0xffffffffffff;

    constr t create() = {
        policy_table = table_create<policy_table_t>(
            (get_policy),
            1,
            get_policy(false, false, false, false, false, false)
        );
        src_prefix_table = PrefixTable.create();
        dst_prefix_table = PrefixTable.create();
    };

    fun bool should_anonymize(HIGH int<48> dmac, bool multicast_broadcast) {
        int<1> dmac_bit = down(dmac[40:40]);
        if (!multicast_broadcast && dmac_bit == 1) {
            return false;
        } else {
            return true;
        }
    }

    fun split_int_t<'sz> anonymize_num(HIGH int<'a> num, bool anonymize_prefix, bool anonymize_suffix) {
        int <'a> prefix_mask = (int<'a>)(FULL_MASK << size_to_int('sz));
        int<'a> prefix = num & prefix_mask;
        int<'sz> suffix = (int<'sz>)(num - prefix);

        bool should_anonymize_prefix = anonymize_prefix;
        if (should_anonymize_prefix) {
            prefix = hash<'a>(SEED, prefix);
        } 
        prefix = prefix >> size_to_int('sz);
        bool should_anonymize_suffix = anonymize_suffix;
        if (should_anonymize_suffix) {
            suffix = hash<'sz>(SEED, suffix);
        }

        return { prefix = down((int<32>)prefix); suffix = down(suffix); };
    }

    fun LOW int<48> anonymize_mac(HIGH int<48> address, bool anonymize_oui, bool anonymize_id) {
        split_int_t<24> split_mac = anonymize_num(address, anonymize_oui, anonymize_id);
        return down((int<24>)(split_mac#prefix) ^ split_mac#suffix);
    }

    fun LOW int anonymize_ip(HIGH int ip_addr, PrefixTable.t table, bool preserve_prefix) {
        int prefix_len = PrefixTable.prefix_match(table, ip_addr);
        bool should_preserve_prefix = preserve_prefix;
        match (down(prefix_len)) with
        | 16 -> {
            split_int_t<16> split_ip = anonymize_num(ip_addr, !should_preserve_prefix, true);
            return down((int<16>)(split_ip#prefix) ^ split_ip#suffix);}
        | 24 -> {
            split_int_t<8> split_ip = anonymize_num(ip_addr, !should_preserve_prefix, true);
            return down((int<24>)(split_ip#prefix) ^ split_ip#suffix);}
        | _ -> {return down(ip_addr);}
    }

    // fun eth_ip_t anonymize_packet(t anonymizer, eth_ip_t eth_ip) {
    fun eth_ip_t anonymize_packet(t anonymizer, 
                                  HIGH int<48> dmac, HIGH int<48> smac, int<16> etype, 
                                  HIGH int src, HIGH int dst, int<16> len) {
        // eth_t eth = eth_ip#eth;
        // ip_t ip = eth_ip#ip;
        policy_t policy = table_match(anonymizer#policy_table, (1), ());
        if (!should_anonymize(dmac, policy#multicast_broadcast)) {
            eth_t eth = {
                dmac = down(dmac);
                smac = down(smac);
                etype = etype;
            };
            ip_t ip = {
                src = down(src);
                dst = down(dst);
                len = len;
            };
            return { eth = eth; ip = ip; };
        } else {
            // anonymize MAC addresses
            int<48> low_smac = anonymize_mac(
                smac, policy#srcmac_oui, policy#srcmac_id);
            int<48> low_dmac = anonymize_mac(
                dmac, policy#dstmac_oui, policy#dstmac_id);
            eth_t anonymized_eth = { dmac = low_dmac; smac = low_smac; etype = etype; };

            // anonymize IPv4 addresses
            int low_src_ip = anonymize_ip(
                src, anonymizer#src_prefix_table, policy#preserve_prefix);
            int low_dst_ip = anonymize_ip(
                dst, anonymizer#dst_prefix_table, policy#preserve_prefix);
            ip_t anonymized_ip = { src = low_src_ip; dst = low_dst_ip; len = len; };

            return { eth = anonymized_eth; ip = anonymized_ip; };
        }
    }
}