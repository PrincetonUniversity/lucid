const int OUT_PORT = 1;
const int SERVER_PORT = 2;
const int SEED = 7;

// Example anonymization policy:
// -Don't anonymize multicast/broadcast
// -Anonymize source + dst MAC OUI + ID
// -Anonymize IP addresses w/ prefixes 172.17.1.0/24, 10.4.0.0/16
//      -Preserve prefixes

// ethernet and ip packet headers
type eth_t = {
	int<48> dmac;
	int<48> smac;
	int<16> etype;
}
type ip_t = {
	int src;
	int dst;
	int<16> len;
    int<16> prefix_len;
}

// prefix lengths of source/dst IP addresses
type ip_prefix_matches = {
    bool src_prefix;
    bool dst_prefix;
}

/********** Events *********/
packet event eth_ip(eth_t eth, ip_t ip);

event anonymize_info(eth_t eth, ip_t ip);

/********** Tables *********/
action bool result(bool b)() {
	return b;
}

table_type prefix_table_v4_t = {
    key_size: (32)
    arg_types: ()
    ret_type: bool
}

global prefix_table_v4_t src_prefix_table_v4 = 
    table_create<prefix_table_v4_t>(
        (result),
        1024,
        result(false)
    );

global prefix_table_v4_t dst_prefix_table_v4 = 
    table_create<prefix_table_v4_t>(
        (result),
        1024,
        result(false)
    );

/********** Functions *********/
fun bool should_anonymize(eth_t eth, ip_t ip) {
    if (eth#dmac[40:40] == 1) { // if multicast/broadcast traffic
        return false;
    } else {
        return true;
    }
}

fun int<auto> get_n_bits(int<auto> num, int<auto> first_bit, int<auto> num_bits) {
    int<auto> shifted_to_first_bit = num >> first_bit;
    int<auto> wanted_bits_removed = shifted_to_first_bit >> num_bits;
    if (wanted_bits_removed != 0) {
        wanted_bits_removed = wanted_bits_removed << num_bits;
    }
    int<auto> wanted_bits = (int<auto>)(shifted_to_first_bit - wanted_bits_removed);
    return wanted_bits;
}

fun int<auto> zero_n_bits(int<auto> num, int<auto> first_bit, int<auto> num_bits) {
    int<auto> bits_to_zero = (get_n_bits(num, first_bit, num_bits)) << first_bit;
    return num - bits_to_zero;
}

fun ip_prefix_matches matches_prefix(ip_t ip) {
    int src_ip_prefix = zero_n_bits(ip#src, 0, 32 - ip#prefix_len);
    int dst_ip_prefix = zero_n_bits(ip#dst, 0, 32 - ip#prefix_len);
    
    bool src_prefix_match = table_match(
		src_prefix_table_v4, 
		(src_ip_prefix), 
		());
    bool dst_prefix_match = table_match(
		dst_prefix_table_v4, 
		(dst_ip_prefix), 
		());

    return {src_prefix = src_prefix_match; dst_prefix = dst_prefix_match;};
}

fun int<24> anonymize_24_bits(int<48> address, bool first_half) {
    if (first_half) {
        return hash<24>(SEED, address[23:0]);
    } else {
        return hash<24>(SEED, address[47:24]);
    }
}

fun int anonymize_ip_prefix_16(int ip) {
    int<16> prefix = ip[31:16];
    int<16> rest = hash<16>(SEED, ip[15:0]);
    return prefix ^ rest;
}

fun int anonymize_ip_prefix_24(int ip) {
    int<24> prefix = ip[31:8];
    int<8> rest = hash<8>(SEED, ip[7:0]);
    return prefix ^ rest;
}

/********** Handlers *********/
handle eth_ip(eth_t eth, ip_t ip) {
	// 1. forward an event representing the packet out of port 1.
	generate_port(OUT_PORT, eth_ip(eth, ip));
	// 2. anonymize packet info before sending to the monitoring server.
    generate(anonymize_info(eth, ip));
}

handle anonymize_info(eth_t eth, ip_t ip) {
    if (!should_anonymize(eth, ip)) {
        generate_port(SERVER_PORT, eth_ip(eth, ip));
    } else {
        // anonymize source + destination MAC addresses
        int<48> smac = anonymize_24_bits(eth#smac, false) ^ anonymize_24_bits(eth#smac, true);
        int<48> dmac = anonymize_24_bits(eth#dmac, false) ^ anonymize_24_bits(eth#dmac, true);
        eth_t anonymized_eth = {eth with dmac = dmac; smac = smac};

        // anonymize src + dst IPv4 addresses
        ip_prefix_matches ip_matches = matches_prefix(ip);
        int src_ip = ip#src;
        if (ip_matches#src_prefix) {
            match (ip#prefix_len) with
            | 16 -> {src_ip = anonymize_ip_prefix_16(ip#src);}
            | 24 -> {src_ip = anonymize_ip_prefix_24(ip#src);}
            | _ -> {src_ip = 0;}
        }
        int dst_ip = ip#dst;
        if (ip_matches#dst_prefix) {
            match (ip#prefix_len) with
            | 16 -> {dst_ip = anonymize_ip_prefix_16(ip#dst);}
            | 24 -> {dst_ip = anonymize_ip_prefix_24(ip#dst);}
            | _ -> {dst_ip = 0;}
        }
        ip_t anonymized_ip = {ip with src = src_ip; dst = dst_ip};

        generate_port(SERVER_PORT, eth_ip(anonymized_eth, anonymized_ip));
    }
}