const int<9> OUT_PORT = 1;
const int<9> SERVER_PORT = 2;

/********** Modules *********/
// module implementing a table to match prefixes of IPv4 addresses
module PrefixTable {
    action int result(int prefix_len)() {
        return prefix_len;
    }

    table_type prefix_table_t = {
        key_size: (32, 32, 32, 32)
        arg_types: ()
        ret_type: int
    }

    type t = {
        prefix_table_t prefix_table;
    }

    constr t create() = {
        prefix_table = table_create<prefix_table_t>(
            (result),
            1024,
            result(0)
        );
    };

    fun int prefix_match(t table, int ip_addr) {
        int<8>[4] ip_octets = [ip_addr[31:24]; ip_addr[23:16]; ip_addr[15:8]; ip_addr[7:0]];
        int prefix_length = table_match(
            table#prefix_table, 
            ((int<32>)ip_octets[0], (int<32>)ip_octets[1], (int<32>)ip_octets[2], (int<32>)ip_octets[3]), 
            ());
        return prefix_length;
    }
}

// module implementing an anonymizer that anonymizes packet info based on the provided policy
module Anonymizer {
    type eth_t = {
        int<48> dmac;
        int<48> smac;
        int<16> etype;
    }

    type ip_t = {
        int src;
        int dst;
        int<16> len;
    }

    type eth_ip_t = {
        eth_t eth;
        ip_t ip;
    }

    type split_int_t<'sz> = {
        int prefix;
        int<'sz> suffix;
    }

    type policy_t = {
        bool multicast_broadcast;
        bool srcmac_oui;
        bool srcmac_id;
        bool dstmac_oui;
        bool dstmac_id;
        bool preserve_prefix;
    }

    action policy_t get_policy(
                    bool multicast_broadcast, 
                    bool srcmac_oui, bool srcmac_id, 
                    bool dstmac_oui, bool dstmac_id, 
                    bool preserve_prefix)() {
        return {
            multicast_broadcast = multicast_broadcast;
            srcmac_oui = srcmac_oui; srcmac_id = srcmac_id;
            dstmac_oui = dstmac_oui; dstmac_id = dstmac_id;
            preserve_prefix = preserve_prefix;
        };
    }

    table_type policy_table_t = {
        key_size: (32)
        arg_types: ()
        ret_type: policy_t
    }

    type t = {
        policy_table_t policy_table;
        PrefixTable.t src_prefix_table;
        PrefixTable.t dst_prefix_table;
    }

    const int SEED = 7;
    const int<48> FULL_MASK = 0xffffffffffff;

    constr t create() = {
        policy_table = table_create<policy_table_t>(
            (get_policy),
            1,
            get_policy(false, false, false, false, false, false)
        );
        src_prefix_table = PrefixTable.create();
        dst_prefix_table = PrefixTable.create();
    };

    fun bool should_anonymize(eth_t eth, bool multicast_broadcast) {
        if (!multicast_broadcast && eth#dmac[40:40] == 1) {
            return false;
        } else {
            return true;
        }
    }

    fun split_int_t<'sz> anonymize_num(int<'a> num, bool anonymize_prefix, bool anonymize_suffix) {
        int <'a> prefix_mask = (int<'a>)(FULL_MASK << size_to_int('sz));
        int<'a> prefix = num & prefix_mask;
        int<'sz> suffix = (int<'sz>)(num - prefix);

        bool should_anonymize_prefix = anonymize_prefix;
        if (should_anonymize_prefix) {
            prefix = hash<'a>(SEED, prefix);
        } 
        prefix = prefix >> size_to_int('sz);
        bool should_anonymize_suffix = anonymize_suffix;
        if (should_anonymize_suffix) {
            suffix = hash<'sz>(SEED, suffix);
        }

        return {prefix = (int<32>)prefix; suffix = suffix;};
    }

    // anonymize mac conditionally anonymizes each part and then concats the outputs.
    fun int<48> anonymize_mac(int<48> address, bool anonymize_oui, bool anonymize_id) {
        split_int_t<24> split_mac = anonymize_num(address, anonymize_oui, anonymize_id);
        return (int<24>)(split_mac#prefix) ^ split_mac#suffix;
    }

    fun int anonymize_ip(int ip_addr, PrefixTable.t table, bool preserve_prefix) {
        int prefix_len = PrefixTable.prefix_match(table, ip_addr);
        bool should_preserve_prefix = preserve_prefix;
        match (prefix_len) with
        | 16 -> {
            split_int_t<16> split_ip = anonymize_num(ip_addr, !should_preserve_prefix, true);
            return (int<16>)(split_ip#prefix) ^ split_ip#suffix;}
        | 24 -> {
            split_int_t<8> split_ip = anonymize_num(ip_addr, !should_preserve_prefix, true);
            return (int<24>)(split_ip#prefix) ^ split_ip#suffix;}
        | _ -> {return ip_addr;}
    }

    fun eth_ip_t anonymize_packet(t anonymizer, eth_ip_t eth_ip) {
        eth_t eth = eth_ip#eth;
        ip_t ip = eth_ip#ip;
        policy_t policy = table_match(anonymizer#policy_table, (1), ());
        if (!should_anonymize(eth, policy#multicast_broadcast)) {
            return {eth = eth; ip = ip;};
        } else {
            // anonymize MAC addresses
            int<48> smac = anonymize_mac(
                eth#smac, policy#srcmac_oui, policy#srcmac_id);
            int<48> dmac = anonymize_mac(
                eth#dmac, policy#dstmac_oui, policy#dstmac_id);
            eth_t anonymized_eth = {eth with dmac = dmac; smac = smac};

            // anonymize IPv4 addresses
            int src_ip = anonymize_ip(
                 ip#src, anonymizer#src_prefix_table, policy#preserve_prefix);
             int dst_ip = anonymize_ip(
                 ip#dst, anonymizer#dst_prefix_table, policy#preserve_prefix);
             ip_t anonymized_ip = {ip with src = src_ip; dst = dst_ip};

            return {eth = anonymized_eth; ip = ip;};
        }
    }

}

global Anonymizer.t anonymizer = Anonymizer.create();

/********** Events *********/
packet event eth_ip(Anonymizer.eth_t eth, Anonymizer.ip_t ip);

/********** Handlers *********/
handle eth_ip(Anonymizer.eth_t eth, Anonymizer.ip_t ip) {
	// 1. forward an event representing the packet out of port 1.
	// generate_port(OUT_PORT, eth_ip(eth, ip));
	// 2. anonymize packet info before sending to the monitoring server.
    Anonymizer.eth_ip_t anonymized_packet = Anonymizer.anonymize_packet(anonymizer, {eth=eth; ip=ip});
    generate_port(SERVER_PORT, eth_ip(anonymized_packet#eth, anonymized_packet#ip));
}

// breakdown of stages

/*
    * policy lookup takes ~3 stages



*/