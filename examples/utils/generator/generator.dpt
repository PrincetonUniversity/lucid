// a packet generator

const int<9> server_port = 148;


// time is in units of 2^16 nanoseconds, or 64 microseconds.
global Array.t<32> txct = Array.create(256);
global Array.t<32> tx_start = Array.create(256);
global Array.t<32> tx_end = Array.create(256);

global Array.t<32> rxct = Array.create(256);
global Array.t<32> rx_start = Array.create(256);
global Array.t<32> rx_end = Array.create(256);


// command events from controller
event send_pkt@1(int<16> ct, int<48> dst, int<48> src, int<16> ety, Payload.t pl);
event send_report@3(int id);
event send_timed_report@13(int id);
event reset@7();

// report events to controller
event report@2(int id, int txct, int rxct){skip;}
event timed_report@12(int id, int txct, int rxct, int txstart, int txend, int rxstart, int rxend){skip;}



// functions and handlers
memop incr(int m, int c) {
    return m + c;
}

packet event eth(int<48> dst, int<48> src, int<16> ety, Payload.t pl) {
    if (ingress_port == server_port) {
        int rx_ct = Array.update(rxct, 0, incr, 1, incr, 1);
        if (rx_ct == 1) {
            Array.set(rx_start, 0, Sys.time());
        }
        Array.set(rx_end, 0, Sys.time());
    }
}

handle send_pkt(int<16> ct, int<48> dst, int<48> src, int<16> ety, Payload.t pl) {
    int tx_ct = Array.update(txct, 0, incr, 1, incr, 1);
    if (tx_ct == 1) {
        Array.set(tx_start, 0, Sys.time());
    }
    Array.set(tx_end, 0, Sys.time());
    // send packet to server
    generate_port(server_port, eth(dst, src, ety, pl));
    // if count is not 1, generate another packet
    if (ct != 1) {
        generate(send_pkt(ct - 1, dst, src, ety, pl));
    }
}


handle send_report(int id) {
    int tx = Array.get(txct, 0);
    int rx = Array.get(rxct, 0);
    generate_port(ingress_port, report(id, tx, rx));
}

handle send_timed_report(int id) {
    int tx = Array.get(txct, 0);
    int txs = Array.get(tx_start, 0);
    int txe = Array.get(tx_end, 0);
    int rx = Array.get(rxct, 0);
    int rxs = Array.get(rx_start, 0);
    int rxe = Array.get(rx_end, 0);
    generate_port(ingress_port, timed_report(id, tx, rx, txs, txe, rxs, rxe));
}

handle reset() {
    Array.set(txct, 0, 0);
    Array.set(tx_start, 0, 0);
    Array.set(tx_end, 0, 0);
    Array.set(rxct, 0, 0);
    Array.set(rx_start, 0, 0);
    Array.set(rx_end, 0, 0);
}


// infinite flow events
event start_flow@5(int<8> flow_id, int<32> max_pkts, int<48>dst, int<48> src, int<16> ety, Payload.t pl);
event stop_flow@6(int<8> flow_id);
event continue_flow@4(int<8> flow_id, int<32> max_ct, int<48> dst, int<48> src, int<16> ety, Payload.t pl);

global Array.t<8> flow_status = Array.create(256);

handle continue_flow(int<8> flow_id, int<32> max_ct, int<48> dst, int<48> src, int<16> ety, Payload.t pl) {
    Array.setm(txct, 0, incr, 1);
    generate_port(server_port, eth(dst, src, ety, pl));
    if (Array.get(flow_status, flow_id) == 1) {
        if (max_ct != 0) {
            generate(continue_flow(flow_id, max_ct - 1, dst, src, ety, pl));
        }
    }
}

handle start_flow(int<8> flow_id, int<32> max_pkts, int<48>dst, int<48> src, int<16> ety, Payload.t pl) {
    Array.set(flow_status, flow_id, 1);
    generate(continue_flow(flow_id, max_pkts, dst, src, ety, pl));
}

handle stop_flow(int<8> flow_id) {
    Array.set(flow_status, flow_id, 0);
}