---LinkP4.ml log---
[link_p4] p4_syntax_tree:
Seq [[
    Noop [[/* 
This harness is for ingress programs that p
    - entry event generators and exit event handlers are generated from 
      ip_harness_triggers.json and inlined into ingress at @ENTRY_TRIGGER_CALL
      and @EXIT_ACTION_CALL
*/]]
    Noop [[#include <core.p4>]]
    Noop [[#include <tna.p4>]]
    Seq [[
        Expr [[]]
        Pragma [[DPT_HEADERS]]()
        ]] EndSeq 
    Noop [[/*=============================================
=            Headers and metadata.            =
=============================================*/]]
    Stmt [[typedef bit<48> mac_addr_t;]]
    Block [[header ethernet_h]]{
        Seq [[
            Stmt [[mac_addr_t dst_addr;]]
            Stmt [[mac_addr_t src_addr;]]
            Stmt [[bit<16> ether_type;]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[header ethernet_h]]
    Stmt [[typedef bit<32> ipv4_addr_t;]]
    Block [[header ipv4_h]]{
        Seq [[
            Stmt [[bit<4> version;]]
            Stmt [[bit<4> ihl;]]
            Stmt [[bit<8> tos;]]
            Stmt [[bit<16> total_len;]]
            Stmt [[bit<16> identification;]]
            Stmt [[bit<3> flags;]]
            Stmt [[bit<13> frag_offset;]]
            Stmt [[bit<8> ttl;]]
            Stmt [[bit<8> protocol;]]
            Stmt [[bit<16> hdr_checksum;]]
            Stmt [[ipv4_addr_t src_addr;]]
            Stmt [[ipv4_addr_t dst_addr;]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[header ipv4_h]]
    Block [[struct ip_event_fields_t]]{
        Seq [[
            Stmt [[bit<8> tos;]]
            Stmt [[bit<16> len;]]
            Stmt [[ipv4_addr_t src;]]
            Stmt [[ipv4_addr_t dst;]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[struct ip_event_fields_t]]
    Noop [[// Global headers and metadata]]
    Block [[struct header_t]]{
        Seq [[
            Stmt [[ethernet_h ethernet;]]
            Seq [[
                Expr [[]]
                Pragma [[DPT_HEADER_INSTANCES]]()
                ]] EndSeq 
            Stmt [[ipv4_h ip;]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[struct header_t]]
    Block [[struct metadata_t]]{
        Seq [[
            Seq [[
                Expr [[]]
                Pragma [[DPT_METADATA_INSTANCES]]()
                ]] EndSeq 
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[struct metadata_t]]
    Seq [[
        Expr [[]]
        Pragma [[DPT_PARSER]]()
        ]] EndSeq 
    Noop [[/*===============================
=            Parsing            =
===============================*/]]
    Noop [[// Parser for tofino-specific metadata.]]
    Block [[parser TofinoIngressParser(
        packet_in pkt,        
        out ingress_intrinsic_metadata_t ig_intr_md,
        out header_t hdr,
        out metadata_t md)]]{
        Seq [[
            Block [[state start]]{
                Seq [[
                    Stmt [[pkt.extract(ig_intr_md);]]
                    Noop [[// DPT: populate metadata.]]
                    Stmt [[md.dptMeta.exitEventType = 0;]]
                    Stmt [[md.dptMeta.nextEventType = 0;]]
                    Stmt [[md.dptMeta.timestamp = (bit<32>)(ig_intr_md.ingress_mac_tstamp[47:16]);]]
                    Block [[transition select(ig_intr_md.resubmit_flag)]]{
                        Seq [[
                            Stmt [[1 : parse_resubmit;]]
                            Stmt [[0 : parse_port_metadata;]]
                            Noop [[]]
                            ]] EndSeq 
                        } EndBlock [[transition select(ig_intr_md.resubmit_flag)]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[state start]]
            Block [[state parse_resubmit]]{
                Seq [[
                    Noop [[// Parse resubmitted packet here.]]
                    Stmt [[transition reject;]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[state parse_resubmit]]
            Block [[state parse_port_metadata]]{
                Seq [[
                    Stmt [[pkt.advance(64);]]
                    Noop [[// skip this.]]
                    Stmt [[transition accept;]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[state parse_port_metadata]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[parser TofinoIngressParser(
        packet_in pkt,        
        out ingress_intrinsic_metadata_t ig_intr_md,
        out header_t hdr,
        out metadata_t md)]]
    Noop [[// MANUAL HARNESS CODE]]
    Stmt [[const bit<16> ETHERTYPE_IPV4 = 16w0x0800;]]
    Stmt [[const bit<16> ETHERTYPE_DPT = 0x1111;]]
    Block [[parser EthIpParser(packet_in pkt, out header_t hdr, out metadata_t md)]]{
        Seq [[
            Stmt [[DptIngressParser() dptIngressParser;]]
            Noop [[// MANUAL HARNESS CODE]]
            Block [[state start]]{
                Seq [[
                    Stmt [[pkt.extract(hdr.ethernet);]]
                    Block [[transition select(hdr.ethernet.ether_type)]]{
                        Seq [[
                            Stmt [[ETHERTYPE_IPV4 : parse_ip;]]
                            Stmt [[ETHERTYPE_DPT  : parse_dpt;]]
                            Stmt [[default : accept;]]
                            Noop [[]]
                            ]] EndSeq 
                        } EndBlock [[transition select(hdr.ethernet.ether_type)]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[state start]]
            Noop [[// MANUAL HARNESS CODE]]
            Block [[state parse_dpt]]{
                Seq [[
                    Stmt [[dptIngressParser.apply(pkt, hdr, md);]]
                    Stmt [[transition parse_ip;]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[state parse_dpt]]
            Block [[state parse_ip]]{
                Seq [[
                    Stmt [[pkt.extract(hdr.ip);]]
                    Stmt [[transition accept;]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[state parse_ip]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[parser EthIpParser(packet_in pkt, out header_t hdr, out metadata_t md)]]
    Block [[parser TofinoEgressParser(
        packet_in pkt,
        out egress_intrinsic_metadata_t eg_intr_md)]]{
        Seq [[
            Block [[state start]]{
                Seq [[
                    Stmt [[pkt.extract(eg_intr_md);]]
                    Stmt [[transition accept;]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[state start]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[parser TofinoEgressParser(
        packet_in pkt,
        out egress_intrinsic_metadata_t eg_intr_md)]]
    Noop [[/*========================================
=            Ingress parsing             =
========================================*/]]
    Block [[parser IngressParser(
        packet_in pkt,
        out header_t hdr, 
        out metadata_t md,
        out ingress_intrinsic_metadata_t ig_intr_md)]]{
        Seq [[
            Block [[state start]]{
                Seq [[
                    Stmt [[TofinoIngressParser.apply(pkt, ig_intr_md, hdr, md);]]
                    Stmt [[EthIpParser.apply(pkt, hdr, md);]]
                    Stmt [[transition accept;]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[state start]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[parser IngressParser(
        packet_in pkt,
        out header_t hdr, 
        out metadata_t md,
        out ingress_intrinsic_metadata_t ig_intr_md)]]
    Block [[control CiL2Fwd(
        in ingress_intrinsic_metadata_t ig_intr_md,
        inout ingress_intrinsic_metadata_for_tm_t ig_tm_md)]]{
        Seq [[
            Noop [[/* Basic L2 forwarding */]]
            Block [[action aiOut(bit<9> out_port)]]{
                Seq [[
                    Stmt [[ig_tm_md.ucast_egress_port = out_port;]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[action aiOut(bit<9> out_port)]]
            Block [[action aiNoop()]]{
                Seq [[
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[action aiNoop()]]
            Block [[action aiReflect()]]{
                Seq [[
                    Stmt [[ig_tm_md.ucast_egress_port = ig_intr_md.ingress_port;]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[action aiReflect()]]
            Block [[table tiWire]]{
                Seq [[
                    Block [[key =]]{
                        Seq [[
                            Stmt [[ig_intr_md.ingress_port : exact;]]
                            Noop [[]]
                            ]] EndSeq 
                        } EndBlock [[key =]]
                    Block [[actions =]]{
                        Seq [[
                            Stmt [[aiOut;]]
                            Stmt [[aiNoop;]]
                            Stmt [[aiReflect;]]
                            Noop [[]]
                            ]] EndSeq 
                        } EndBlock [[actions =]]
                    Stmt [[const default_action = aiReflect();]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[table tiWire]]
            Block [[apply]]{
                Seq [[
                    Stmt [[tiWire.apply();]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[apply]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[control CiL2Fwd(
        in ingress_intrinsic_metadata_t ig_intr_md,
        inout ingress_intrinsic_metadata_for_tm_t ig_tm_md)]]
    Noop [[/*===========================================
=            ingress match-action             =
===========================================*/]]
    Block [[control Ingress(
        inout header_t hdr, 
        inout metadata_t md,
        in ingress_intrinsic_metadata_t ig_intr_md,
        in ingress_intrinsic_metadata_from_parser_t ig_prsr_md,
        inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
        inout ingress_intrinsic_metadata_for_tm_t ig_tm_md)]]{
        Seq [[
            Seq [[
                Expr [[]]
                Pragma [[ENTRY_OBJECTS]]()
                ]] EndSeq 
            Seq [[
                Expr [[]]
                Pragma [[EXIT_OBJECTS]]()
                ]] EndSeq 
            Seq [[
                Expr [[]]
                Pragma [[DPT_OBJECTS]]()
                ]] EndSeq 
            Stmt [[CiL2Fwd() ciL2Fwd;]]
            Block [[apply]]{
                Seq [[
                    Noop [[// call the entry trigger table.]]
                    Seq [[
                        Expr [[]]
                        Pragma [[ENTRY_CALL]]()
                        ]] EndSeq 
                    Noop [[// If there's an event, call the Lucid handlers.]]
                    Block [[if (md.dptMeta.eventType != 0)]]{
                        Seq [[
                            Seq [[
                                Expr [[]]
                                Pragma [[DPT_HANDLERS]]()
                                ]] EndSeq 
                            Noop [[// Handle any exit events produced by lucid.]]
                            Seq [[
                                Expr [[]]
                                Pragma [[EXIT_CALL]]()
                                ]] EndSeq 
                            Noop [[]]
                            ]] EndSeq 
                        } EndBlock [[if (md.dptMeta.eventType != 0)]]
                    Noop [[// If there was no event, don't call lucid.]]
                    Block [[else]]{
                        Seq [[
                            Stmt [[ciL2Fwd.apply(ig_intr_md, ig_tm_md);]]
                            Noop [[]]
                            ]] EndSeq 
                        } EndBlock [[else]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[apply]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[control Ingress(
        inout header_t hdr, 
        inout metadata_t md,
        in ingress_intrinsic_metadata_t ig_intr_md,
        in ingress_intrinsic_metadata_from_parser_t ig_prsr_md,
        inout ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md,
        inout ingress_intrinsic_metadata_for_tm_t ig_tm_md)]]
    Block [[control IngressDeparser(
        packet_out pkt, 
        inout header_t hdr, 
        in metadata_t md,
        in ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md)]]{
        Seq [[
            Block [[apply]]{
                Seq [[
                    Stmt [[pkt.emit(hdr);]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[apply]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[control IngressDeparser(
        packet_out pkt, 
        inout header_t hdr, 
        in metadata_t md,
        in ingress_intrinsic_metadata_for_deparser_t ig_dprsr_md)]]
    Noop [[/*======================================
=            Egress parsing            =
======================================*/]]
    Block [[parser EgressParser(
        packet_in pkt,
        out header_t hdr, 
        out metadata_t eg_md,
        out egress_intrinsic_metadata_t eg_intr_md)]]{
        Seq [[
            Stmt [[TofinoEgressParser() tofino_parser;]]
            Stmt [[EthIpParser() eth_ip_parser;]]
            Block [[state start]]{
                Seq [[
                    Stmt [[tofino_parser.apply(pkt, eg_intr_md);]]
                    Stmt [[transition parse_packet;]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[state start]]
            Block [[state parse_packet]]{
                Seq [[
                    Stmt [[eth_ip_parser.apply(pkt, hdr, eg_md);]]
                    Stmt [[transition accept;]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[state parse_packet]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[parser EgressParser(
        packet_in pkt,
        out header_t hdr, 
        out metadata_t eg_md,
        out egress_intrinsic_metadata_t eg_intr_md)]]
    Noop [[/*=========================================
=            Egress match-action            =
=========================================*/]]
    Block [[control Egress(
        inout header_t hdr, 
        inout metadata_t eg_mg,
        in egress_intrinsic_metadata_t eg_intr_md,
        in egress_intrinsic_metadata_from_parser_t eg_prsr_md,
        inout egress_intrinsic_metadata_for_deparser_t eg_dprsr_md,
        inout egress_intrinsic_metadata_for_output_port_t eg_oport_md)]]{
        Seq [[
            Seq [[
                Expr [[]]
                Pragma [[DPT_EGRESS_OBJECTS]]()
                ]] EndSeq 
            Block [[apply]]{
                Seq [[
                    Seq [[
                        Expr [[]]
                        Pragma [[DPT_EGRESS]]()
                        ]] EndSeq 
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[apply]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[control Egress(
        inout header_t hdr, 
        inout metadata_t eg_mg,
        in egress_intrinsic_metadata_t eg_intr_md,
        in egress_intrinsic_metadata_from_parser_t eg_prsr_md,
        inout egress_intrinsic_metadata_for_deparser_t eg_dprsr_md,
        inout egress_intrinsic_metadata_for_output_port_t eg_oport_md)]]
    Block [[control EgressDeparser(
        packet_out pkt,
        inout header_t hdr, 
        in metadata_t eg_md,
        in egress_intrinsic_metadata_for_deparser_t eg_dprsr_md)]]{
        Seq [[
            Block [[apply]]{
                Seq [[
                    Stmt [[pkt.emit(hdr);]]
                    Noop [[]]
                    ]] EndSeq 
                } EndBlock [[apply]]
            Noop [[]]
            ]] EndSeq 
        } EndBlock [[control EgressDeparser(
        packet_out pkt,
        inout header_t hdr, 
        in metadata_t eg_md,
        in egress_intrinsic_metadata_for_deparser_t eg_dprsr_md)]]
    Noop [[/*==============================================
=            The switch's pipeline             =
==============================================*/]]
    Stmt [[Pipeline(
    IngressParser(), Ingress(), IngressDeparser(),
    EgressParser(), Egress(), EgressDeparser()) pipe;]]
    Stmt [[Switch(pipe) main;]]
    ]] EndSeq 

[pragma_replace_trans] -------------- block: DPT_OBJECTS--------------
[pragma_replace_trans] code:
 
    bit<32> a1_out;
    
    bit<32> a2_out;
    
    Register<fmt_arr_1, bit<32>>(1024) arr_1;
    
    Register<fmt_arr_2, bit<32>>(1024) arr_2;
    
    
    
    RegisterAction<fmt_arr_1,bit<32>,bit<32>>(arr_1) dpt_776_sprog_809_salu_0_opstmt = {
        void apply(inout fmt_arr_1 remote, out bit<32> remoteRet) {
            fmt_arr_1 local = remote;
            bit<32> remoteHi = 0;
            if (local.lo == 10) { remote.lo = 0; }
            if (! (local.lo == 10)) { remote.lo = (1 + local.lo); }
            
            remoteRet = remote.lo;
            }
        };
        action dpt_776_salu_0_opstmt() {
            a1_out=dpt_776_sprog_809_salu_0_opstmt.execute((bit<32>)0);
        }
        
        action dpt_786_merged_acn_1_noop( ){
            //next tables: []
            
        }
        
        action dpt_776_merged_acn_1_acn_0_opstmt( ){
            dpt_776_salu_0_opstmt();
            //next tables: [dpt_777_tbl_0_opstmt]
            
        }
        
        @pragma stage 0
        @ignore_table_dependency("Ingress.dpt_2_merged_tbl")
        table dpt_1_merged_tbl {
            key = {
                md.dptMeta.eventType : ternary;
            }
            actions = {
                dpt_776_merged_acn_1_acn_0_opstmt;
                dpt_786_merged_acn_1_noop;
            }
            const entries = {
                1 : dpt_776_merged_acn_1_acn_0_opstmt();
                _ : dpt_786_merged_acn_1_noop();
            }
            
        }
        
        RegisterAction<fmt_arr_2,bit<32>,bit<32>>(arr_2) dpt_777_sprog_810_salu_0_opstmt = {
            void apply(inout fmt_arr_2 remote, out bit<32> remoteRet) {
                fmt_arr_2 local = remote;
            bit<32> remoteHi = 0;
            remote.lo = md.ip_in.src;
            
            if (local.lo == md.ip_in.dst) { remoteHi = 1; }
            if (! (local.lo == md.ip_in.dst)) { remoteHi = 0; }
            remoteRet = remoteHi;
                }
            };
            action dpt_777_salu_0_opstmt() {
                a2_out=dpt_777_sprog_810_salu_0_opstmt.execute((bit<32>)0);
            }
            
            action dpt_777_merged_acn_2_acn_0_opstmt( ){
                dpt_777_salu_0_opstmt();
                //next tables: [dpt_779_tbl_0_opstmt]
                
            }
            
            @pragma stage 0
            @ignore_table_dependency("Ingress.dpt_1_merged_tbl")
            table dpt_2_merged_tbl {
                key = {
                    md.dptMeta.eventType : ternary;
                }
                actions = {
                    dpt_777_merged_acn_2_acn_0_opstmt;
                    dpt_786_merged_acn_1_noop;
                }
                const entries = {
                    1 : dpt_777_merged_acn_2_acn_0_opstmt();
                    _ : dpt_786_merged_acn_1_noop();
                }
                
            }
            
            action dpt_779_generate_port_alu_0_opstmt( ){
                md.ip_out.src = a1_out;
                md.ip_out.dst = a2_out;
                md.ip_out.eventType = 2;
                md.ip_out.eventLoc = 0;
                md.ip_out.eventDelay = 0;
                md.dptMeta.exitEventType = 2;
                ig_tm_md.ucast_egress_port = md.ip_in.igr_port;
                
            }
            
            action dpt_779_merged_acn_3_acn_0_opstmt( ){
                dpt_779_generate_port_alu_0_opstmt();
                //next tables: []
                
            }
            
            @pragma stage 1
            table dpt_3_merged_tbl {
                key = {
                    md.dptMeta.eventType : ternary;
                }
                actions = {
                    dpt_779_merged_acn_3_acn_0_opstmt;
                    dpt_786_merged_acn_1_noop;
                }
                const entries = {
                    1 : dpt_779_merged_acn_3_acn_0_opstmt();
                    _ : dpt_786_merged_acn_1_noop();
                }
                
            }
             
    action from_any_to_none() {
  ig_dprsr_md.drop_ctl = 0x1;
  exit;
}
action from_bg_to_wire() {
  hdr.ethernet.ether_type = 0x0800;
  hdr.lucid_footer.setInvalid();
  hdr.ev_out_flags.setInvalid();
}
action from_wire_to_bg() {
  ig_tm_md.mcast_grp_a = 1065 + md.dptMeta.eventsCount;
  hdr.ethernet.ether_type = 0x1111;
  exit;
}
action from_wire_to_bg_wire() {
  ig_tm_md.mcast_grp_a = 1065 + md.dptMeta.eventsCount;
  hdr.ethernet.ether_type = 0x1111;
}
table dpt_0_lucid_return_table {
  key = {
    md.dptMeta.eventType : ternary;
    md.dptMeta.eventsCount : ternary;
    md.dptMeta.exitEventType : ternary;
  }
  actions = {
    from_any_to_none; from_bg_to_wire; from_wire_to_bg; from_wire_to_bg_wire;
  }
  const entries = {
    (_, 0, 0) : from_any_to_none();
    (_, 0, _) : from_bg_to_wire();
    (_, _, 0) : from_wire_to_bg();
    (_, _, _) : from_wire_to_bg_wire();
  }
}
    
[pragma_replace_trans] -------------- block: DPT_DISPATCH--------------
[pragma_replace_trans] code:
 
    dpt_1_merged_tbl.apply();
    dpt_2_merged_tbl.apply();
    dpt_3_merged_tbl.apply(); 
    dpt_0_lucid_return_table.apply();
[pragma_replace_trans] -------------- block: DPT_HANDLERS--------------
[pragma_replace_trans] code:
 
    dpt_1_merged_tbl.apply();
    dpt_2_merged_tbl.apply();
    dpt_3_merged_tbl.apply(); 
    dpt_0_lucid_return_table.apply();
[pragma_replace_trans] -------------- block: DPT_HEADERS--------------
[pragma_replace_trans] code:
    #define e_ip_in 1
    #define e_ip_out 2
    #define e_raw_out 3
    struct fmt_arr_1 {
        bit<32> lo;
    }
    struct fmt_arr_2 {
        bit<32> lo;
    }
    struct ip_in_t {
        bit<8> eventType;
        bit<32> eventLoc;
        bit<32> eventDelay;
        bit<9> igr_port;
        bit<32> src;
        bit<32> dst;
        bit<16> len;
        bit<8> tos;
    }
    struct ip_out_t {
        bit<8> eventType;
        bit<32> eventLoc;
        bit<32> eventDelay;
        bit<32> src;
        bit<32> dst;
    }
    struct raw_out_t {
        bit<8> eventType;
        bit<32> eventLoc;
        bit<32> eventDelay;
    }
    header lucid_footer_t {
        bit<8> end;
    }
    header ev_out_flags_t {
        bit<1> ip_in;
        bit<1> ip_out;
        bit<1> raw_out;
        bit<5> pad_1_meta;
    }
    struct dptMeta_t {
        bit<32> timestamp;
        bit<8> eventType;
        bit<8> exitEventType;
        bit<8> nextEventType;
        bit<16> eventsCount;
        bit<9> outPort;
        bit<16> outGroup;
    }
[pragma_replace_trans] -------------- block: DPT_HEADER_INSTANCES--------------
[pragma_replace_trans] code:
    lucid_footer_t lucid_footer;
    ev_out_flags_t ev_out_flags;
[pragma_replace_trans] -------------- block: DPT_METADATA_INSTANCES--------------
[pragma_replace_trans] code:
    ip_in_t ip_in;
    ip_out_t ip_out;
    raw_out_t raw_out;
    dptMeta_t dptMeta;
[pragma_replace_trans] -------------- block: DPT_PARSER--------------
[pragma_replace_trans] code:
parser DptIngressParser (packet_in pkt, out header_t hdr, out metadata_t md) {
    state start {
        md.dptMeta.eventType = pkt.lookahead<bit<8>>();
        transition select(md.dptMeta.eventType) {
            0 : finish;
            
        }
    }
    state selector_1 {
        bit<8> tmp = pkt.lookahead<bit<8>>();
        transition select(tmp) {
            0 : finish;
            
        }
    }
    state selector_2 {
        bit<8> tmp = pkt.lookahead<bit<8>>();
        transition select(tmp) {
            0 : finish;
            
        }
    }
    state selector_3 {
        bit<8> tmp = pkt.lookahead<bit<8>>();
        transition select(tmp) {
            0 : finish;
            
        }
    }
    state finish {
        pkt.extract(hdr.lucid_footer);
        
        pkt.extract(hdr.ev_out_flags);
        transition accept;
        
    }
}
[pragma_replace_trans] -------------- block: DPT_EGRESS_OBJECTS--------------
[pragma_replace_trans] code:
 
    action acn_nonlucid_wire() {
  
}
action acn_lucid_wire() {
  hdr.ethernet.ether_type = 0x0800;
  hdr.lucid_footer.setInvalid();
  hdr.ev_out_flags.setInvalid();
}
table dpt_0_egr_serialize_clone {
  key = {
    hdr.ethernet.ether_type : ternary;
    eg_intr_md.egress_rid : ternary;
  }
  actions = {
    acn_nonlucid_wire; acn_lucid_wire;
  }
  const entries = {
    (2048, 0) : acn_nonlucid_wire();
    (4369, 0) : acn_lucid_wire();
  }
}
    
[pragma_replace_trans] -------------- block: DPT_EGRESS--------------
[pragma_replace_trans] code:
 
    dpt_0_egr_serialize_clone.apply();
[pragma_replace_trans] -------------- block: ENTRY_OBJECTS--------------
[pragma_replace_trans] code:
action trigger_ip_in() {
  md.dptMeta.eventType=e_ip_in;
  md.ip_in.igr_port = ig_intr_md.ingress_port;
  md.ip_in.src = hdr.ip.src_addr;
  md.ip_in.dst = hdr.ip.dst_addr;
  md.ip_in.len = hdr.ip.total_len;
  md.ip_in.tos = hdr.ip.tos;
}
table entry_table {
  key = {
    hdr.ip.isValid() : ternary;
    ig_intr_md.ingress_port : ternary;
  }
  actions = {
    trigger_ip_in;
  }
  const entries = {
    (true, 128) : trigger_ip_in();
  }
}
[pragma_replace_trans] -------------- block: ENTRY_CALL--------------
[pragma_replace_trans] code:
if (md.dptMeta.eventType == 0) { entry_table.apply();}
[pragma_replace_trans] -------------- block: EXIT_OBJECTS--------------
[pragma_replace_trans] code:
action a_ip_out() {
  hdr.ip.src_addr = md.ip_out.src;
  hdr.ip.dst_addr = md.ip_out.dst;
}
action a_raw_out() {
  
}
table exit_table {
  key = {
    md.dptMeta.exitEventType : ternary;
  }
  actions = {
    a_ip_out; a_raw_out;
  }
  const entries = {
    (e_ip_out) : a_ip_out();
    (e_raw_out) : a_raw_out();
  }
}
[pragma_replace_trans] -------------- block: EXIT_CALL--------------
[pragma_replace_trans] code:
if (md.dptMeta.exitEventType != 0) { exit_table.apply();}
