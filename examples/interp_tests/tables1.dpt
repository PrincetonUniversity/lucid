// test all the basic table components: 
// actions, table_type, multi-field table return, 
// table_create, table_match, table_install, table_multi_install

type res_t = {
  int val;
  bool is_hit;
}

action res_t hit_acn(int x)(int a) {
  return {val = x; is_hit = true};
}

action res_t miss_acn(bool b)(int a) {
  return {val = a; is_hit = b};
}
// extend parsing to not need parens around single element tuples
table_type ftbl_t = {
  key_size: (32)
  arg_types: (int)
  ret_type: res_t
}
global ftbl_t ftbl = table_create<ftbl_t>((hit_acn, miss_acn), 1024, miss_acn(false));

event do_match(int<<32>> s) {
  int a = 1000;
  res_t tbl_out = table_match(ftbl, (s), (a)); 

  printf("return of table match: %d", tbl_out#val);
  if (tbl_out#is_hit) {
    printf ("table HIT.");
  }
  else {
    printf ("table MISS. Installing hit_acn(3) for current key. ");    
    table_install(ftbl, 
      {(s) -> hit_acn(3)}
      );    
    // what if we don't want to forward the packet on until the rule gets installed?
    // table update ? Maybe the same as install.
    // table delete, takes pattern.
  }
}
/*


*/



event do_install(int<<32>> v, int<<32>> m) {
  printf("installing entry: (%d &&& %d)", v, m);
  table_multi_install(ftbl, 
    {(v) -> hit_acn(2); 
      (v &&& m) -> hit_acn(3)}
      );
 }