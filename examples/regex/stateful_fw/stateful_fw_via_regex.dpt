type eth_hdr = {
    int<<48>> dmac; 
    int<<48>> smac; 
    int<<16>> etype;
}
type ip_hdr_prefix = {
    int<<8>> v_ihl; 
    int<<8>> tos;
    int<<16>> len;
    int<<16>> id;
    int<<16>> flags_frag;
    int<<8>> ttl;
    int<<8>> proto;
    int<<16>> csum;
}
entry event ip_pkt (eth_hdr eth, ip_hdr_prefix ip, int<<32>> src, int<<32>> dst);

const int<<8>> TOS_TRUSTED = 1;
const int<<9>> out_port = 100;

re<<4096>> allowed = ip_pkt (@int start_time = Sys.time(); ip#tos == TOS_TRUSTED)
    .(ip_pkt(ip#tos == TOS_TRUSTED) 
        || ((ip_pkt(!(ip#tos == TOS_TRUSTED)) 
            && ip_pkt(Sys.time() - start_time < 10000))))*
    .((ip_pkt(!(ip#tos == TOS_TRUSTED)) 
            && ip_pkt(!(Sys.time() - start_time < 10000))));
global Array.t<<32>> times = Array.create(4096);
memop set_m(int memval, int input) {
    return input;
}
memop get_m(int memval, int input) {
    return memval;
}
handle ip_pkt (eth_hdr eth, ip_hdr_prefix ip, int<<32>> src, int<<32>> dst) {
    int idx = (int<<32>>)hash<<12>>(19, src, dst);
    if (transition(allowed, idx)) {
        printf("Detected timeout error!");
    }
    int t = Array.update(times, idx, get_m, 0, set_m, Sys.time());
    if (ip#tos == TOS_TRUSTED || (Sys.time() - t < 10000)) {
        generate_port(out_port, this);
    }
}