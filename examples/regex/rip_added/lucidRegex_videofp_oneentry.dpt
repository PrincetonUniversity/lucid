

entry event packet_in(int sip, int dip, int<<16>> sport, int<<16>> dport, int<<16>> pkt_size);
exit event packet_out(int sip, int dip, int<<16>> sport, int<<16>> dport, int<<16>> pkt_size);
exit event match_report();

memop get_stored (int stored, int dummy){return stored;}
memop wipe(int stored, int dummy){return 0;}
memop incr (int stored_ct, int incr_by) {return stored_ct + incr_by;}

alphabet sizes = S1, S2, S3, S4, S5, S6, S7, S8;

global Array.t<<32>> arr = Array.create(256);
re<<256>> RE_fingerprint_videoA over sizes = (S1.S5.S1.S4.S7.S8.S1.S2);


handle packet_in(int sip, int dip, int<<16>> sport, int<<16>> dport, int<<16>> s){
	generate packet_out(sip, dip, sport, dport, s);
	int<<32>> idx = (int<<32>>)hash<<8>>(13, sip, dip, sport,dport);

	if(s > 130){
		Array.setm(arr, idx, incr, 1);
	}else{
		int r = Array.update(arr, idx, get_stored, 0, wipe, 0);
		event S=S1();

		match s with 
		| 0b00000000000000** -> {S = S1();}
		| 0b000000000000**** -> {S = S2();}
		| 0b0000000000****** -> {S = S3();}
		| 0b00000000******** -> {S = S4();}
		| 0b000000********** -> {S = S5();}
		| 0b0000************ -> {S = S6();}
		| 0b00************** -> {S = S7();}
		| _ -> {S = S8();}

		if(transition(RE_fingerprint_videoA, idx, S)){
			generate match_report();
		}
	}
}

// Data-plane implementation of single-destination RIP, with possibility of
// route retraction

const int TRUE = 1;
const int FALSE = 0;

const int dst_ip = 1234; // The single destination

// Recall that we have two builtin variables representing locations:
const int self = 1; //(This switch)
const group neighbors = {2, 3, 4}; //(Multicast group for all neighbors of this switch)

const int num_neighbors = 3;
global Array.t<<32>> edge_lengths = Array.create(num_neighbors); // Initialized by the control plane, or at compile time
global Array.t<<32>> neighbor_dists = Array.create(num_neighbors);
global Array.t<<32>> best_dist = Array.create(1);
global Array.t<<32>> best_neighbor = Array.create(1);

const int ADVERTISE_PERIOD = 1000;
const int SCAN_PERIOD = 100;

// Represents your neighbor telling you their distance to the target
event advertise(int neighbor, int dist);
// Loop to periodically send advertisements
event gen_advertise();
// In case of route retraction -- periodically scan through your neighbors to
// ensure your current best is accurate
event scan(int idx);
// I couldn't find a way to implement advertise without recirculation.
event set_best_dist(int dist);

memop id (int x, int dummy) {
    return x;
}

memop eq (int x, int y) {
    if (x == y) {
        return TRUE;
    } else {
        return FALSE;
    }
}

memop smaller(int x, int y) {
    if (y < x) {
        return TRUE;
    } else {
        return FALSE;
    }
}

memop min(int x, int y) {
    if (x < y) {
        return x;
    } else {
        return y;
    }
}

handle advertise(int neighbor, int dist) {
     // For convenience I'm assuming neighbors can also be used as indices into
     // edge_lengths and neighbor_dists; in reality we might hash them or have
     // P4 precompute keys or something.
     int edge_length = Array.get(edge_lengths, neighbor);
     int totaldist = dist + edge_length;

     // Update our info
     Array.set(neighbor_dists, neighbor, totaldist);

     // Update our best distance if the new dist is smaller, and return TRUE if so
     int updated = Array.update(best_dist, 0, smaller, totaldist, min, totaldist);

     if (updated == TRUE) {
      // Set the best neighbor to this one and readvertise to neighbors
        Array.set(best_neighbor, 0, neighbor);
        generate_ports(neighbors, advertise(self, totaldist));
     } else {
         // Check if this neighbor was already the best. If it was, and the route length
         // increased, our best distance may no longer be accurate.
         int was_already_best = Array.getm(best_neighbor, 0, eq, neighbor);
         if (was_already_best == TRUE) {
           // Set the best distance to the current one; scan will eventually sort things out
             generate set_best_dist(totaldist);
         }
     }
}

handle set_best_dist(int dist) {
    Array.set(best_dist, 0, dist);
}

handle gen_advertise() {
    int best = Array.get(best_dist, 0);
    generate_ports(neighbors, advertise(self, best));
    generate Event.delay(gen_advertise(), ADVERTISE_PERIOD);
}

handle scan(int idx) {
    int dist = Array.get(neighbor_dists, idx);
    int updated = Array.update(best_dist, 0, smaller, dist, min, dist);
    if(updated == TRUE) {
        Array.set(best_neighbor, 0, idx);
    }

    // int next_idx = idx + 1;
    // if ((next_idx + 1) > num_neighbors) { next_idx = 0; }
    // rewrite to avoid inequality scan (and subexpression in if)
    int next_idx = idx + 1;
    if (next_idx == num_neighbors) {next_idx = 0;}
    generate Event.delay(scan(next_idx), SCAN_PERIOD);
}

entry event packetin(int dst);
exit event continue(int dst);

handle packetin(int dst) {
    if (dst == dst_ip) {
        int best = Array.get(best_neighbor, 0);
        generate continue(best);
    }
}